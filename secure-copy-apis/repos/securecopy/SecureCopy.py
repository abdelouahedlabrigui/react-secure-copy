from flask import Flask, request, jsonify
import paramiko
import oracledb
import json
import datetime
import os
import tempfile
from functools import wraps
import logging
from typing import Dict, List, Tuple, Optional

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DeviceConfig:
    """Configuration class for device connection details"""
    def __init__(self, username: str, password: str, host: str, directory: str):
        self.username = username
        self.password = password
        self.host = host
        self.directory = directory

class DatabaseManager:
    """Handles Oracle database operations for logging"""
    def __init__(self, dsn: str, username: str, password: str):
        self.dsn = dsn
        self.username = username
        self.password = password
    
    def get_connection(self):
        """Get Oracle database connection"""
        try:
            return oracledb.connect(user=self.username, password=self.password, dsn=self.dsn, mode=oracledb.SYSDBA)
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            raise

    def log_operation(self, operation_type: str, device_info: Dict, request_data: Dict, response_data: Dict, status: str):
        """Log API operation to database"""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()

                # Create table if not exists (run this separately in production)
                create_table_sql = """
                CREATE TABLE IF NOT EXISTS api_logs (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    operation_type VARCHAR2(50),
                    device_info CLOB,
                    request_data CLOB,
                    response_data CLOB,
                    status VARCHAR2(20)
                )
                """

                try:
                    cursor.execute(create_table_sql)
                except:
                    pass

                # Insert log entry
                insert_sql = """
                INSERT INTO api_logs (operation_type, device_info, request_data, response_data, status) 
                VALUES (:1, :2, :3, :4, :5)
                """

                cursor.execute(insert_sql, (
                    operation_type, 
                    json.dumps(device_info),
                    json.dumps(request_data),
                    json.dumps(response_data),
                    status
                ))
                conn.commit()

        except Exception as e:
            logger.error(f"Failed to log operation: {e}")

class SSHManager:
    """Handles SSH connections and operations using paramiko"""

    @staticmethod
    def create_ssh_client(device_config: DeviceConfig) -> paramiko.SSHClient:
        """Create and configure SSH client"""
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            client.connect(
                hostname=device_config.host,
                username=device_config.username,
                password=device_config.password,
                timeout=30
            )

            return client
        except Exception as e:
            logger.error(f"SSH connection failed to {device_config.host}: {e}")
            raise

    @staticmethod
    def execute_command(client: paramiko.SSHClient, command: str) -> Tuple[str, str, int]:
        """Execute command via SSH and return stdout, stderr, exit_code"""
        try:
            stdin, stdout, stderr = client.exec_command(command)
            exit_code = stdout.channel.recv_exit_status()

            stdout_text = stdout.read().decode('utf-8').strip()
            stderr_text = stderr.read().decode('utf-8').strip()

            return stdout_text, stderr_text, exit_code
        except Exception as e:
            logger.error(f"Command execution failed: {e}")
            raise

class SCPManager:
    """Handles SCP operations between devices"""

    @staticmethod
    def transfer_file(source_device: DeviceConfig, dest_device: DeviceConfig, source_path: str, dest_path: str) -> Dict:
        """Transfer file between devices using SCP"""
        temp_file = None
        try:
            # Step 1: Download file from source device to local temp
            source_client = SSHManager.create_ssh_client(source_device)
            sftp_source = source_client.open_sftp()

            temp_file = tempfile.NamedTemporaryFile(delete=False)
            temp_file.close()

            sftp_source.get(source_path, temp_file.name)
            file_stats = sftp_source.stat(source_path)

            sftp_source.close()
            source_client.close()

            # Step 2: Upload file from local temp to destination device
            dest_client = SSHManager.create_ssh_client(dest_device)
            sftp_dest = dest_client.open_sftp()

            sftp_dest.put(temp_file.name, dest_path)

            sftp_dest.close()
            dest_client.close()

            return {
                "success": True,
                "source_path": source_path,
                "destination_path": dest_path,
                "file_size": file_stats.st_size,
                "transfer_time": datetime.datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"File transfer failed: {e}")
            return {
                "success": False,
                "error": str(e),
                "source_path": source_path,
                "destination_path": dest_path
            }
        finally:
            if temp_file and os.path.exists(temp_file.name):
                os.unlink(temp_file.name)